/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    BlogPost: ClassViewer<'BlogPost', "title" | "subtitle" | "meta_description" | "tags" | "estimated_read_time" | "sections" | "call_to_action">;
    
    BlogRequest: ClassViewer<'BlogRequest', "topic" | "target_audience" | "tone" | "length" | "key_points" | "include_examples" | "seo_keywords">;
    
    BlogSection: ClassViewer<'BlogSection', "heading" | "content" | "key_points">;
    
    Change: ClassViewer<'Change', "type" | "description" | "before" | "after">;
    
    CodeExample: ClassViewer<'CodeExample', "language" | "description" | "code">;
    
    DecompositionRequest: ClassViewer<'DecompositionRequest', "query" | "depth" | "validation">;
    
    DecompositionResult: ClassViewer<'DecompositionResult', "primary_queries" | "validation_queries" | "edge_queries">;
    
    DocSection: ClassViewer<'DocSection', "heading" | "content" | "subsections">;
    
    Documentation: ClassViewer<'Documentation', "title" | "overview" | "sections" | "code_examples" | "related_topics" | "last_updated">;
    
    DocumentationRequest: ClassViewer<'DocumentationRequest', "topic" | "doc_type" | "target_audience" | "include_code_examples" | "programming_language" | "existing_content">;
    
    EditRequest: ClassViewer<'EditRequest', "content" | "focus" | "target_tone" | "preserve_voice" | "max_word_count">;
    
    EditedContent: ClassViewer<'EditedContent', "original_word_count" | "edited_word_count" | "content" | "changes_made" | "readability_score">;
    
    Email: ClassViewer<'Email', "subject" | "greeting" | "body" | "closing" | "signature" | "tone_used">;
    
    EmailRequest: ClassViewer<'EmailRequest', "purpose" | "recipient" | "context" | "email_type" | "tone" | "key_points" | "sender_name" | "sender_title">;
    
    ExecutiveBrief: ClassViewer<'ExecutiveBrief', "title" | "date" | "research_question" | "key_findings" | "critical_distinctions" | "confidence_summary" | "strategic_implications" | "recommended_actions" | "read_time">;
    
    FactCheckRequest: ClassViewer<'FactCheckRequest', "claims" | "context">;
    
    FactCheckResponse: ClassViewer<'FactCheckResponse', "results" | "overall_accuracy" | "red_flags">;
    
    FactCheckResult: ClassViewer<'FactCheckResult', "claim" | "verdict" | "explanation" | "sources" | "nuance">;
    
    Finding: ClassViewer<'Finding', "claim" | "confidence" | "sources" | "contradictions">;
    
    FollowUpSuggestion: ClassViewer<'FollowUpSuggestion', "query" | "rationale" | "estimated_depth" | "priority">;
    
    QualityMetrics: ClassViewer<'QualityMetrics', "coverage_score" | "confidence_score" | "depth_score" | "overall_grade">;
    
    ResearchGap: ClassViewer<'ResearchGap', "topic" | "importance" | "suggested_query">;
    
    ResearchRequest: ClassViewer<'ResearchRequest', "query" | "focus" | "boundary" | "depth" | "existing_knowledge">;
    
    ResearchResult: ClassViewer<'ResearchResult', "summary" | "key_findings" | "sources" | "gaps" | "follow_ups" | "quality" | "methodology">;
    
    Resume: ClassViewer<'Resume', "name" | "email" | "experience" | "skills">;
    
    Source: ClassViewer<'Source', "url" | "title" | "snippet" | "source_type" | "authority_score" | "recency" | "bias_indicator">;
    
    SubQuery: ClassViewer<'SubQuery', "query" | "focus" | "priority" | "boundary">;
    
    SynthesisRequest: ClassViewer<'SynthesisRequest', "original_query" | "research_results" | "fact_check" | "output_format">;
    
    SynthesisResult: ClassViewer<'SynthesisResult', "executive_brief" | "detailed_analysis" | "source_appendix" | "quality">;
    
    TranslateRequest: ClassViewer<'TranslateRequest', "content" | "target_language" | "source_language" | "preserve_formatting" | "localize" | "domain">;
    
    TranslatedContent: ClassViewer<'TranslatedContent', "source_language" | "target_language" | "original_content" | "translated_content" | "translation_notes" | "cultural_adaptations">;
    
    ValidationRequest: ClassViewer<'ValidationRequest', "query" | "context">;
    
    ValidationResult: ClassViewer<'ValidationResult', "is_clear" | "topics" | "relationship" | "time_period" | "primary_sources" | "recommended_structure" | "clarification_needed">;
    
    
    ContentLength: EnumViewer<'ContentLength', "Short" | "Medium" | "Long" | "Extended">;
    
    DocType: EnumViewer<'DocType', "API" | "Tutorial" | "HowTo" | "Reference" | "Conceptual" | "Troubleshooting" | "Changelog">;
    
    EditFocus: EnumViewer<'EditFocus', "Grammar" | "Clarity" | "Conciseness" | "Tone" | "Structure" | "All">;
    
    EmailType: EnumViewer<'EmailType', "Introduction" | "FollowUp" | "Request" | "ThankYou" | "Apology" | "Announcement" | "Proposal" | "ColdOutreach">;
    
    WritingTone: EnumViewer<'WritingTone', "Professional" | "Casual" | "Technical" | "Persuasive" | "Academic" | "Friendly">;
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "BlogPost","BlogRequest","BlogSection","Change","CodeExample","DecompositionRequest","DecompositionResult","DocSection","Documentation","DocumentationRequest","EditRequest","EditedContent","Email","EmailRequest","ExecutiveBrief","FactCheckRequest","FactCheckResponse","FactCheckResult","Finding","FollowUpSuggestion","QualityMetrics","ResearchGap","ResearchRequest","ResearchResult","Resume","Source","SubQuery","SynthesisRequest","SynthesisResult","TranslateRequest","TranslatedContent","ValidationRequest","ValidationResult",
          ]),
          enums: new Set([
            "ContentLength","DocType","EditFocus","EmailType","WritingTone",
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.BlogPost = this.tb.classViewer("BlogPost", [
          "title","subtitle","meta_description","tags","estimated_read_time","sections","call_to_action",
        ]);
        
        this.BlogRequest = this.tb.classViewer("BlogRequest", [
          "topic","target_audience","tone","length","key_points","include_examples","seo_keywords",
        ]);
        
        this.BlogSection = this.tb.classViewer("BlogSection", [
          "heading","content","key_points",
        ]);
        
        this.Change = this.tb.classViewer("Change", [
          "type","description","before","after",
        ]);
        
        this.CodeExample = this.tb.classViewer("CodeExample", [
          "language","description","code",
        ]);
        
        this.DecompositionRequest = this.tb.classViewer("DecompositionRequest", [
          "query","depth","validation",
        ]);
        
        this.DecompositionResult = this.tb.classViewer("DecompositionResult", [
          "primary_queries","validation_queries","edge_queries",
        ]);
        
        this.DocSection = this.tb.classViewer("DocSection", [
          "heading","content","subsections",
        ]);
        
        this.Documentation = this.tb.classViewer("Documentation", [
          "title","overview","sections","code_examples","related_topics","last_updated",
        ]);
        
        this.DocumentationRequest = this.tb.classViewer("DocumentationRequest", [
          "topic","doc_type","target_audience","include_code_examples","programming_language","existing_content",
        ]);
        
        this.EditRequest = this.tb.classViewer("EditRequest", [
          "content","focus","target_tone","preserve_voice","max_word_count",
        ]);
        
        this.EditedContent = this.tb.classViewer("EditedContent", [
          "original_word_count","edited_word_count","content","changes_made","readability_score",
        ]);
        
        this.Email = this.tb.classViewer("Email", [
          "subject","greeting","body","closing","signature","tone_used",
        ]);
        
        this.EmailRequest = this.tb.classViewer("EmailRequest", [
          "purpose","recipient","context","email_type","tone","key_points","sender_name","sender_title",
        ]);
        
        this.ExecutiveBrief = this.tb.classViewer("ExecutiveBrief", [
          "title","date","research_question","key_findings","critical_distinctions","confidence_summary","strategic_implications","recommended_actions","read_time",
        ]);
        
        this.FactCheckRequest = this.tb.classViewer("FactCheckRequest", [
          "claims","context",
        ]);
        
        this.FactCheckResponse = this.tb.classViewer("FactCheckResponse", [
          "results","overall_accuracy","red_flags",
        ]);
        
        this.FactCheckResult = this.tb.classViewer("FactCheckResult", [
          "claim","verdict","explanation","sources","nuance",
        ]);
        
        this.Finding = this.tb.classViewer("Finding", [
          "claim","confidence","sources","contradictions",
        ]);
        
        this.FollowUpSuggestion = this.tb.classViewer("FollowUpSuggestion", [
          "query","rationale","estimated_depth","priority",
        ]);
        
        this.QualityMetrics = this.tb.classViewer("QualityMetrics", [
          "coverage_score","confidence_score","depth_score","overall_grade",
        ]);
        
        this.ResearchGap = this.tb.classViewer("ResearchGap", [
          "topic","importance","suggested_query",
        ]);
        
        this.ResearchRequest = this.tb.classViewer("ResearchRequest", [
          "query","focus","boundary","depth","existing_knowledge",
        ]);
        
        this.ResearchResult = this.tb.classViewer("ResearchResult", [
          "summary","key_findings","sources","gaps","follow_ups","quality","methodology",
        ]);
        
        this.Resume = this.tb.classViewer("Resume", [
          "name","email","experience","skills",
        ]);
        
        this.Source = this.tb.classViewer("Source", [
          "url","title","snippet","source_type","authority_score","recency","bias_indicator",
        ]);
        
        this.SubQuery = this.tb.classViewer("SubQuery", [
          "query","focus","priority","boundary",
        ]);
        
        this.SynthesisRequest = this.tb.classViewer("SynthesisRequest", [
          "original_query","research_results","fact_check","output_format",
        ]);
        
        this.SynthesisResult = this.tb.classViewer("SynthesisResult", [
          "executive_brief","detailed_analysis","source_appendix","quality",
        ]);
        
        this.TranslateRequest = this.tb.classViewer("TranslateRequest", [
          "content","target_language","source_language","preserve_formatting","localize","domain",
        ]);
        
        this.TranslatedContent = this.tb.classViewer("TranslatedContent", [
          "source_language","target_language","original_content","translated_content","translation_notes","cultural_adaptations",
        ]);
        
        this.ValidationRequest = this.tb.classViewer("ValidationRequest", [
          "query","context",
        ]);
        
        this.ValidationResult = this.tb.classViewer("ValidationResult", [
          "is_clear","topics","relationship","time_period","primary_sources","recommended_structure","clarification_needed",
        ]);
        
        
        this.ContentLength = this.tb.enumViewer("ContentLength", [
          "Short","Medium","Long","Extended",
        ]);
        
        this.DocType = this.tb.enumViewer("DocType", [
          "API","Tutorial","HowTo","Reference","Conceptual","Troubleshooting","Changelog",
        ]);
        
        this.EditFocus = this.tb.enumViewer("EditFocus", [
          "Grammar","Clarity","Conciseness","Tone","Structure","All",
        ]);
        
        this.EmailType = this.tb.enumViewer("EmailType", [
          "Introduction","FollowUp","Request","ThankYou","Apology","Announcement","Proposal","ColdOutreach",
        ]);
        
        this.WritingTone = this.tb.enumViewer("WritingTone", [
          "Professional","Casual","Technical","Persuasive","Academic","Friendly",
        ]);
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}